{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Warning</p> <p>Ongoing project, not ready for release or usage yet. Many features are still missing.</p> <p>This library offers a mostly-compliant[^1] XML parser, tree builder and several related utilities. It is not intended as a general purpose library, which means it might not be a good fit for your project. Please, read the rest of this readme for more information.  </p>"},{"location":"embedded/","title":"Embedded","text":"<p>Most usage of <code>libc++</code> is only related to header features, so it might be possible to introduce alternatives: - <code>libfmt</code> to cover <code>std::format</code> and <code>std::print</code>. - Some implementation for <code>std::vector</code>, <code>std::stack</code> and <code>std::unordered_map</code>.</p>"},{"location":"layout/","title":"Layout","text":"<p>The memory layout for the tree structure used by this library has the following properties: - It is based on a contiguous memory slice. - It is built in-place, as such children are placed directly after their parent. - Pointers between nodes in the tree are not defined as absolute, but relative to the address of the current one.</p> <p>The structure of the various nodes is based on the size of three data types: - <code>delta_ptr_t</code> is the type of a relative pointer. Realistically, 16bits is plenty enough for most realistic scenarios with XML files humans can handle. - <code>xml_size_t</code> is the type used to represent the size of nodes in bytes. It should be as high as the max size in byte a tree can have. 16bits is also often sufficient. - <code>xml_count_t</code> is the type used to represent the count of things. Like the number of attributes, or number of bytes in a string. Its size is mostly determined by the maximum length of strings_views. Depending on the application as low as 8bit could be enough, 16bit a more reasonable default. - <code>xml_enum_size_t</code> is the size of enums when stored. 8bit is plenty enough.</p> <p>Note</p> <p>If you want to use a very compact memory layout more suitable for embedded applications, you will have to manually override parts of this code and possibly work with bitfields.  </p> <p>This goes beyond the configurability granted via macros and forking this library is likely the best solution.</p>"}]}