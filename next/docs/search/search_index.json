{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Warning</p> <p>Ongoing project. Many features are still missing and documentation has not a full coverage.</p> <p>This library offers a mostly-compliant<sup>1</sup> XML parser, tree builder, query engine and several related utilities. It is not intended as a general purpose library, which means it might not be a good fit for your project. Please, read the rest of the original readme to know more about its objectives and drawbacks. Or continue with this documentation which offers a more in-depth description of several topics.</p> <ol> <li> <p>XML 1.0 is covered as a best-effort, but there will be small things where either the official XML standard or this implementation is going to be incompatible or a superset.   For more information on compatibility, please check here.\u00a0\u21a9</p> </li> </ol>"},{"location":"benchmarks/","title":"Benchmarks","text":"<p><code>pugixml</code> is considered as baseline. These results are preliminary and will be replaced with a more formal benchmark suite, they are just intended to manage expectations correctly.  </p>"},{"location":"benchmarks/#parsing-xml","title":"Parsing XML","text":"<p>Moving from XML to the memory representation on the big dataset nasa_10_f_bs, skipping escaping/de-escaping (<code>raw_strings</code> true) and without managing symbols (<code>EXTERN_REL</code>), is around 0.45x the base throughput of <code>pugixml</code>. Different configurations, like <code>COMPRESSED_ALL</code> or even just <code>OWNED</code> are clearly going to be more expensive (twice as slow for the worst case observed compared to <code>EXTERN_REL</code>), but reducing the default types size has a positive impact (between 20 and 30% improvement observed over the original 0.45x).</p> <p>This is to be expected, as this library handles namespaces, has a higher memory footprint by default, and is forced to work with relative pointers throughout, which require some additional computation. So the slowdown is pretty tame overall, for what is intended as a rare operation. The expectation is that, once preprocessed, only the binary version of the original XML is going to be used.</p> <p>By comparison, loading the binary version is orders of magnitude faster due to the lazy loading as a memory mapped file. This is kind of cheating, but pugixml does not have a comparable feature, so I cannot do much about that. Even forcing a workload which requires access to the full buffer, this library when loading the binary is about 1.2 times the base pugixml speed. This is in a worst-case memory footprint, reducing the default data types will improve performance as disk access is reduced.  </p> <p>A more valid measure of performance will depend on the workload, and is going to be considered in a separate section.</p>"},{"location":"benchmarks/#saving-as-xml","title":"Saving as XML","text":"<p>Unsurprisingly, this is where <code>vs.xml</code> is weak by comparison. It is around 10% of pugixml speed. This is mostly due to my poor implementation but also the underwhelming performance of <code>std::format</code>. Moving to <code>fmt::format</code> we are now around 27% of pugixml speed, which is quite a bump. This metric will be surely improved as there is no good reason for it to be this bad, but XML serialization is not meant as a common operation for the scope of the library, so this result is not very impactful.</p>"},{"location":"benchmarks/#tree-construction","title":"Tree construction","text":"<p>To be tested.</p>"},{"location":"benchmarks/#filtering-searching","title":"Filtering &amp; searching","text":"<p>To be tested.</p>"},{"location":"configuration/","title":"Configuration","text":"<p>For performance reasons, most configuration flags are defined at compile-time. A single application will have to build and link different versions of this library if they want different configurations, but that scenario is extremely unlikely.</p>"},{"location":"configuration/#meson-project","title":"Meson project","text":"<ul> <li><code>tests</code> defaults to false. Change to enable test-suite.</li> <li><code>benchmarks</code> defaults to false. Change to enable benchmarks.</li> <li><code>examples</code> defaults to false. Change to enable examples.</li> <li><code>utils</code> defaults to true. Change to compile the extra system utilities.</li> <li><code>use_fmt</code> defaults to true. Disable it if you want to force using <code>std::print</code>/<code>std::format</code> instead, but be mindful they are much slower.</li> <li><code>use_gtl</code> defaults to false. Enable it to use alternative STL-like containers with better performance and memory-mappability (is that even a word?).</li> </ul>"},{"location":"configuration/#defines","title":"Defines","text":"<ul> <li><code>VS_XML_NS</code> defaults to <code>xml</code>. Changes the namespace if needed, to avoid collisions.</li> <li><code>VS_XML_NO_ASSERT</code> to remove assertions from this library.</li> <li><code>VS_XML_NO_EXCEPT</code> to remove exceptions from this library as much as possible.</li> <li><code>VS_XML_LAYOUT</code> is used to control the memory layout (defaults to 0). Current profiles:<ul> <li><code>0</code> Normal/aligned</li> <li><code>1</code> Compact (mostly compatible with real world documents, less cache-misses, less space on disk)</li> </ul> </li> </ul>"},{"location":"configuration/#data-types-layout","title":"Data types &amp; Layout","text":"<p>The memory layout for the tree structure used by this library has the following properties:</p> <ul> <li>It is based on a contiguous memory slice.</li> <li>It is built in-place, as such children are placed directly after their parent.</li> <li>Attributes are immediately stored after a node.</li> <li>Pointers between nodes in the tree are not defined as absolute, but relative to the address of the current one.</li> <li>All strings are represented as string views over a common base offset which is valid for the whole tree.</li> </ul> <p>The structure of the various nodes is based on the size of three data types:</p> <ul> <li><code>delta_ptr_t</code> is the type of relative pointers. Realistically, 16bits is plenty enough for most realistic scenarios with XML files humans can handle.</li> <li><code>xml_size_t</code> is the type used to represent the size of nodes in bytes. It should be as high as the max size in byte a tree can have. 16bits is also often sufficient.</li> <li><code>xml_count_t</code> is the type used to represent the count of things. Like the number of attributes, or number of bytes in a string. Its size is mostly determined by the maximum length of strings_views. Depending on the application as low as 8bit could be enough, 16bit a more reasonable default.</li> <li><code>xml_enum_size_t</code> is the size of enums when stored. 8bit is plenty enough.</li> </ul> <p>Note</p> <p>If you have very specific needs for a compact memory layout, probably more suitable for embedded applications, you will have to manually override parts of this code and possibly work with bit-fields.  This goes beyond the configurability granted via macros, and forking this library is likely the best solution.</p>"},{"location":"configuration/#builder","title":"Builder","text":"<p>Builders are parametrized by a configuration structure and initialized in ways which defines its behaviour and ownership of data.</p>"},{"location":"configuration/#configuration-fields","title":"Configuration fields","text":"<ul> <li><code>allow_comments</code> if true allows comments to be appended in the tree, else they are silently skipped (but can still throw exceptions for validation)</li> <li><code>allow_procs</code> if true allows processing directives to be appended in the tree, else they are silently skipped (but can still throw exceptions for validation)</li> <li><code>symbols</code>:<ul> <li><code>EXTERN_ABS</code> using full memory in absolute position; the generated tree cannot be saved as binary.</li> <li><code>EXTERN_REL</code> can be saved as binary, but it requires the tree to bind a symbol table later when constructed.</li> <li><code>OWNED</code> no compression of symbols, but they are owned.</li> <li><code>COMPRESS_LABELS</code> only compressing symbols which are used for tag and prop labels (and namespaces).</li> <li><code>COMPRESS_ALL</code> all symbols are compressed.</li> </ul> </li> <li><code>raw_strings</code> if true, strings are assumed to be kept as is when serialized or deserialized from XML. Make sure you manually escape those used in comparisons or to append further data.</li> </ul>"},{"location":"faq/","title":"Faq","text":"<p>Why the binary serialization of the XML is bigger compared to the base file?</p> <p>That is to be expected. XML has very little overhead, with very little in terms of extra symbols and markers. By comparison, this library represents nodes by storing contextual information about their neighbours to speed up navigation. This additional pre-computed information explains the bigger memory footprint. Even when compressed via gzip, the source XML retains a meaningful edge.  </p> <p>So, why should I save the binary serialization?</p> <p>Because you don\u2019t need to parse the original file again. You just need to memory-map it and use it as is. This lowers start-up time quite to zero if using <code>mmap</code>, and will only load pages for the content you need, regardless of the original file size. Such approach can massively boot real world performance on huge files, but also positively impact smaller ones as it operates lazily.</p> <p>What is the point of a representation which is not mutable? Why cannot I edit the tree?</p> <p>Technically it is not immutable; however some types of mutations would be very expensive, almost like rebuilding the entire tree from scratch. Still, there are some operations which are quite fast, like reordering attributes in-place, changing strings with symbols already stored in memory, or adding annotations to the original document. Some of these operations are implemented by this library, others could be in a nearby future or delegated to downstream integrations.  </p> <p>As for why, there is plenty of applications where mutability of the tree structure is only needed during construction, and only for the next token to append. This library tries to optimize such cases without introducing features which could compromise their performance.</p> <p>Why pointers are internally represented as relative to a base?</p> <p>To allow them to be serialized, and still provide random access to the tree regardless of the device or medium on which it ends up being stored. This allows to share annotations of a tree for cheap, even while offloading or distributing computation. Also, results of complex queries are fully portable and easy to share.</p> <p>Why is XML serialization/de-serialization single threaded?</p> <p>Simple answer, laziness. A more serious reply would be that serialization and de-serialization are meant to be just one-off operations. The bulk of whatever computation we must perform is going to act on the binary representation, not the original text. There is no trivial way to make XML parsing or serialization \u201cparallel\u201d without making the code involved much more complex. At which point it is generally better to waste threads for other tasks if possible.</p> <p>How to annotate a tree?</p> <p>References to XML nodes and attributes have a method <code>addr</code> to return their portable address. Keeping a hash map or a similar data structure does the trick. You should be using a data structure which can be easily serialized/de-serialized, or even better which can be memory-mapped if feasible. The standard C++ library is not your best option, you might want to check for alternative like gtl.</p> <p>How to cache queries?</p> <p>At the moment this is not directly supported by the library and will likely never be. However, we plan to introduce features to make it easier on downstream code. Right now, queries are not trivially hash-able. At some point we will add a query builder to structure query trees into linear buffers, more or less like we do with XML. The evolving plans for this feature are reporte in a specifications document. Until then, a similar solution has to be implemented fully downstream.</p>"},{"location":"features/","title":"Features","text":""},{"location":"features/#standard-compatibility","title":"Standard compatibility","text":""},{"location":"features/#xml-parsing","title":"XML parsing","text":"<ul> <li> namespaces <sup>1</sup></li> <li> cdata<ul> <li> optional reduction to <code>text</code> not gonna do that, we will have a unified iterator.</li> </ul> </li> <li> text<ul> <li> optional merging of close text blocks not gonna do that, we will have a unified iterator.</li> </ul> </li> <li> comments <ul> <li> optional stripping</li> </ul> </li> <li> basic entities</li> <li> complex entities</li> </ul>"},{"location":"features/#xml-serialization","title":"XML serialization","text":"<ul> <li> namespaces</li> <li> processing</li> <li> cdata</li> <li> text</li> <li> comments</li> <li> output configurability<ul> <li> indentation</li> <li> newline style</li> <li> other linting</li> </ul> </li> </ul>"},{"location":"features/#library-features","title":"Library features","text":""},{"location":"features/#tree-builder","title":"Tree builder","text":"<ul> <li> namespaces</li> <li> processing</li> <li> cdata</li> <li> text</li> <li> comments</li> </ul>"},{"location":"features/#algorithms","title":"Algorithms","text":"<ul> <li> iterators for nodes</li> <li> iterators for attributes</li> <li> tree/sub-tree cloning<ul> <li> Basic copy</li> <li> String compression</li> </ul> </li> <li> attributes reordering</li> <li> node injection</li> <li> simplified tree wrapper to avoid xml::sv-&gt;string_view conversions.</li> </ul>"},{"location":"features/#queries","title":"Queries","text":""},{"location":"features/#portability","title":"Portability","text":"<ul> <li> <code>noexcept</code> mode</li> <li> <code>noassert</code> mode</li> <li> no memory allocations<ul> <li> for the tree/documents binary representation</li> <li> in the query builder<sup>2</sup></li> <li> in tree building<sup>2</sup></li> <li> in query processing<sup>3</sup></li> </ul> </li> </ul> <ol> <li> <p>Partially, no validation for them\u00a0\u21a9</p> </li> <li> <p>The objective is to pass custom allocators so that arena strategies can be implemented for example.\u00a0\u21a9\u21a9</p> </li> <li> <p>Queries allocates as a stack, so specific strategies and allocator can be adopted for them.\u00a0\u21a9</p> </li> </ol>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#installing","title":"Installing","text":"<p>Use it as a meson dependency, be it a subproject of after installing it on your system.  </p> <p>The process is basically as usual:</p> <pre><code>meson setup build           #Add more flags to setup release, lto optimizations etc based on your needs\nmeson install -C build      #You might have to define DESTDIR to perform a dry run or if you have a strange location\n</code></pre> <p>A simplified makefile is made available, which has some reasonable defaults.  </p> <p>Tarballs will also be offered for some distributions as part of future releases.  </p>"},{"location":"usage/#usage","title":"Usage","text":"<p>TBW</p>"},{"location":"usage/#configuration","title":"Configuration","text":"<p>Read this.</p>"},{"location":"usage/#integration-examples","title":"Integration examples","text":""},{"location":"usage/#external-index","title":"External index","text":""},{"location":"usage/#containers-ranges","title":"Containers &amp; ranges","text":""},{"location":"usage/#performing-queries","title":"Performing queries","text":""},{"location":"examples/","title":"Index","text":"<p>Please, also check the <code>examples</code> folder in the repository for full code.</p>"},{"location":"examples/complex-queries/","title":"Complex queries","text":""},{"location":"examples/complex-queries/#tbw","title":"TBW","text":""},{"location":"examples/memory-mapping/","title":"Memory mapping","text":""},{"location":"examples/memory-mapping/#what-is-memory-mapping","title":"What is memory mapping?","text":""},{"location":"examples/memory-mapping/#using-mio","title":"Using <code>mio</code>","text":""},{"location":"examples/memory-mapping/#loading-file","title":"Loading file","text":""},{"location":"examples/memory-mapping/#saving-file","title":"Saving file","text":""},{"location":"examples/memory-mapping/#mutable-operations","title":"Mutable operations?","text":""},{"location":"examples/optimization/","title":"Optimization","text":""},{"location":"examples/optimization/#embedded-applications","title":"Embedded applications","text":""},{"location":"examples/optimization/#disable-exceptions","title":"Disable exceptions","text":""},{"location":"examples/optimization/#limit-memory-allocations","title":"Limit memory allocations","text":""},{"location":"examples/shared-symbols/","title":"Shared symbols","text":""},{"location":"examples/shared-symbols/#reusing-symbols","title":"Reusing symbols","text":""},{"location":"examples/simple-builders/","title":"Simple builders","text":""},{"location":"examples/simple-builders/#building-a-tree","title":"Building a tree","text":""},{"location":"examples/simple-builders/#building-a-document","title":"Building a document","text":""},{"location":"examples/simple-builders/#saving-to-xml","title":"Saving to XML","text":""},{"location":"examples/simple-builders/#saving-to-binary","title":"Saving to binary","text":""},{"location":"examples/simple-loading/","title":"Simple loading","text":""},{"location":"examples/simple-loading/#basic-xml-parsing","title":"Basic XML parsing","text":""},{"location":"examples/simple-loading/#simple-queries","title":"Simple queries","text":""},{"location":"releases/v0.2.1/","title":"V0.2.1","text":"<p>Release to propagate (the minor) breaking changes downstream. We don\u2019t have many new features visible, but a lot of work in the background to improve the code base and its scope. For reference, <code>v0.2.x</code> should provide as main features: </p> <ul> <li>Queries</li> <li>Multiple documents sharing symbols (and related binary format)</li> <li>Helpers for annotations (but they might be rescheduled for <code>v0.3.x</code> based on how much feature creep is met as it relates to tree injection which is its own beast to handle)</li> </ul> <p>As minor features:</p> <ul> <li>Support for iterators to visit text across <code>text</code> and <code>cdata</code> boundaries.</li> <li>Apply replacement for serialization functions which don\u2019t use memory allocations in the serialization code (already implemented, not used)</li> </ul> <p>Several steps have been made to implement both, but they cannot be tested still (probably there will be queries mostly done in v0.2.3).</p>"},{"location":"releases/v0.2.1/#changes","title":"Changes","text":"<ul> <li>Removed virtually all explicit exceptions.</li> <li>Removed memory allocations for a wide range of operations.</li> <li>Improvements to the binary format.</li> <li>Initial work to support shared symbol tables, annotations and queries. </li> <li>More entry-points for customization, like some containers or predefined reduced memory layouts.</li> <li>Structural improvements in the repo, code quality etc.</li> </ul>"},{"location":"releases/v0.2.1/#breaking-features","title":"Breaking features","text":"<ul> <li>The binary format changed.</li> <li>Several functions had some minor changes, like <code>[[nodiscard]]</code> being added, or <code>std::expected</code> in place of exceptions.</li> </ul>"},{"location":"specs/formats/","title":"Formats","text":""},{"location":"specs/formats/#memory-layout","title":"Memory Layout","text":""},{"location":"specs/formats/#layout-encoding","title":"Layout encoding","text":""},{"location":"specs/formats/#binary-serialization","title":"Binary serialization","text":"<p>Except for a small header, the binary serialization of a tree is identical to its representation in memory.</p>"},{"location":"specs/formats/#header-format","title":"Header format","text":"<p>TBW.</p>"},{"location":"specs/formats/#multi-doc-archives","title":"Multi-doc archives","text":"<p>TBW.</p>"},{"location":"specs/formats/#indices","title":"Indices","text":"<p>TBW.</p>"},{"location":"specs/queries/","title":"Queries","text":""},{"location":"specs/queries/#what-are-queries","title":"What are queries?","text":"<p>Queries are the main mechanism to perform search operations on the binary XML files. There are three main clause types:</p> <ul> <li><code>is</code> iterates over all nodes form a container (like a prior query) as long as all criteria are met.</li> <li><code>has</code> iterates over all nodes from a container (like a prior query), for which the <code>is</code> clause is tested against the query criterion. Those for which at least one solution is defined are picked.</li> <li><code>maps</code> (not implemented yet) iterates over all nodes from a container (like a prior query), and matches results for node in the query tree onto a map-like structure. </li> </ul>"},{"location":"specs/queries/#structure-of-queries","title":"Structure of queries","text":"<p>A query is a linear sequence of query tokens. Most are meant to match specific features of the XML nodes, while some are used to control the \u201cmachine\u201d running the query validation process. Every complete query should end with an <code>accept()</code> token.</p>"},{"location":"specs/queries/#basic-commands","title":"Basic commands","text":"<ul> <li><code>fork()</code> to force splitting matching by continuing here and expanding down.</li> <li><code>accept()</code> to accept the current node and let the iterator go deeper.</li> <li><code>type({...})</code> to match a subset of node type.</li> <li><code>match_ns({exp})</code> to match the namespace, with exp being either a string or a boolean lambda.</li> <li><code>match_name({exp})</code> to match the name, with exp being either a string or a boolean lambda.</li> <li><code>match_value({exp})</code> to match the value, with exp being either a string or a boolean lambda.</li> <li><code>match_all_text({exp})</code> to match the text, with exp being either a string or a boolean lambda.</li> <li><code>attr({name, fn, ns})</code> if a given attribute (with namespace) satisfies the expressions (as string or boolean lambdas). </li> </ul>"},{"location":"specs/queries/#about-attributes","title":"About attributes","text":"<p>Attributes are handled differently compared to the rest of the XML nodes, because they are not. <code>attr</code> will exclusively test the attribute and not bind or capture it. This is true even when running <code>is</code> clauses. If you must capture attributes, you will have to do that by manually iterating or filtering them, like <code>item.attrs() | std::views::filter(...)</code>.</p>"},{"location":"specs/queries/#string-shorthands","title":"String shorthands","text":"<p>Several of the basic commands introduce earlier are also available in a simplified form, represented by string views:</p> <ul> <li><code>\"{ns}:{name}\"</code> matching namespace and name. Special values <code>?</code> for each to determine anything matches that slot. Empty string is considered empty string, and not a generic \u201cmatch all\u201d.</li> <li><code>*</code> to accept any node and move forward.</li> <li><code>**</code> to recursively fork.</li> </ul>"},{"location":"specs/queries/#composition","title":"Composition","text":"<p>Tokens of a query can be composed by any of the following operators:</p> <ul> <li><code>operator*</code> to append right to the current (left) list</li> <li><code>operator/</code> to append a <code>next()</code> AND right to left.</li> </ul>"},{"location":"specs/queries/#applying-queries","title":"Applying queries","text":"<p>Queries are applied either by:</p> <ul> <li>Using the <code>is</code>, <code>has</code> or <code>capture</code> functions.</li> <li>The operators <code>&amp;</code> and <code>|</code> which are alias for <code>is</code> and <code>has</code> respectively.</li> </ul> <p>Applied queries return asynchronous generators, so they can be further piped by <code>std::views::filter</code>.</p>"},{"location":"specs/query-builder/","title":"Query builder","text":"<p>Not implemented yet, just basic specs to sketch a new feature built on top of queries (and to build queries).</p> <p>Queries as they are right now are flexible, but not optimal for all applications:</p> <ul> <li>They cannot be easily serialized and de-serialized as they involve <code>std::function</code> in the variadic.</li> <li>They cannot be easily hashed for the reason above, and because they are made of many split memory segments.</li> <li>The lack of a quick way to hash makes the process of caching queries impractical.</li> </ul> <p>This proposal introduces a flat-tree representation for queries, which are going to perform better in those specific instances. They will be unable to store lambdas, but it is always possible to add some kind of scripting capability I guess (downstream, I don\u2019t think it is good to have that in here).</p> <p>Unlike the tree navigation of XML, where being able to go back to parent with no further contextual information is important, queries are always directed downwards. Also, aside for alignment purposes, there is no good reason to leave strings in a separate table, and they are much more less likely to be repeated. So having a split structural and symbol table might not be as beneficial.  </p> <p>Still, a layout of fully regular cells seems quite a good idea to me.</p> <p>Sketching layout or something.</p> <pre><code>BEGIN(3) OP OP OP \n    BEGIN(0)\n        BEGIN(1) OP\n        END\n        BEGIN(2) OP OP\n        END\n    END\n    BEGIN(0)\n        BEGIN(1) OP\n        END\n    END\nEND\nEOQ #end of query\n\n</code></pre> <p>Extra operation <code>END</code> used to mark end of branch and trace back.</p> <p>Operands are only string_views, details about their interpretation is left to the BEGIN block. END blocks only cover an offset to the parent, to ensure navigation back is possible.  Fully linear structures can avoid storing end tags, as they will never be used.</p> <pre><code>struct token_base{\n    operation_t op;     //5 bits\n    size_t operands;    //~~4~~ 3 bits\n\n    operands type = 8 * 2 bit = 16bit.\n\n    payload/alignment   //WORD-8bit\n};\n\nstruct operand_t{\n    data_kind_t kind;\n    std::string_view data;\n}\n\n</code></pre>"}]}