{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Warning</p> <p>Ongoing project, not ready for release or usage yet. Many features are still missing.</p> <p>This library offers a mostly-compliant<sup>1</sup> XML parser, tree builder and several related utilities. It is not intended as a general purpose library, which means it might not be a good fit for your project. Please, read the rest of this readme to know more about its objectives and drawbacks.</p> <ol> <li> <p>XML 1.0 is covered as a best-effort, but there will be small things where either the official XML standard or this implementation is going to be incompatible or a superset.   For more information on compatibility, please check here.\u00a0\u21a9</p> </li> </ol>"},{"location":"faq/","title":"Faq","text":"<p>Why the binary serialization of the XML is bigger compared to the base file?</p> <p>That is to be expected. XML has very little overhead, with extra symbols and marker. By comparison, nodes as represented by this library are storing contextual information about their neighbours to speed up navigation. This additional pre-computed information explains the bigger size. Even when compressed via gzip, the source XML retains a meaningful edge.  </p> <p>So, why should I save the binary serialization?</p> <p>Because you don\u2019t need to parse the file after the first time. You just need to memory-map it and use it as is. This lowers start-up time quite a bit and gives you constant access to its content regardless of size.</p> <p>What is the point of a representation which is not mutable? Why cannot I edit the tree?</p> <p>Technically it is not immutable; however some types of mutations would be very expensive, almost like rebuilding the tree from scratch. However, there are some which are quite fast, like reordering attributes, changing value with literals which are already in memory, or adding annotations to mark changes. Some of them are implemented by this library, others could be in a nearby future.  </p> <p>As for why, there is plenty of applications where a mutable tree structure is no longer needed after it has being built. This library tries to optimize such cases without introducing features which could compromise them.</p> <p>Why pointers are internally represented as relative to a base?</p> <p>To allow them to be serialized, and still provide random access to the tree regardless of the device or medium on which it is being stored. This allows to share annotations for a tree for cheap, even while offloading or distributing computation.</p> <p>Why is XML serialization/de-serialization single threaded?</p> <p>Because they are mostly meant as one-time operations, while the bulk of the operations is going to be on the binary representation. There is no trivial way to make XML parsing or serialization \u201cparallel\u201d without making the code involved much more complex. At which point it is generally better to waste threads for other tasks if possible.</p>"},{"location":"features/","title":"Features","text":""},{"location":"features/#standard-compatibility","title":"Standard compatibility","text":""},{"location":"features/#features","title":"Features","text":""},{"location":"features/#xml-parsing","title":"XML parsing","text":"<ul> <li> namespaces <sup>1</sup></li> <li> cdata<ul> <li> optional reduction to <code>text</code></li> </ul> </li> <li> text<ul> <li> optional merging of close text blocks</li> </ul> </li> <li> comments <ul> <li> optional stripping</li> </ul> </li> <li> basic entities</li> <li> complex entities</li> </ul>"},{"location":"features/#tree-builder","title":"Tree builder","text":"<ul> <li> namespaces</li> <li> processing</li> <li> cdata</li> <li> text</li> <li> comments</li> </ul>"},{"location":"features/#algorithms","title":"Algorithms","text":"<ul> <li> iterators for nodes</li> <li> iterators for attributes</li> <li> tree/sub-tree cloning<ul> <li> Basic copy</li> <li> String compression</li> </ul> </li> <li> attributes reordering</li> <li> node injection</li> <li> simplified tree wrapper to avoid xml::sv-&gt;string_view conversions.</li> </ul>"},{"location":"features/#xml-serialization","title":"XML serialization","text":"<ul> <li> namespaces</li> <li> processing</li> <li> cdata</li> <li> text</li> <li> comments</li> <li> output configurability<ul> <li> indentation</li> <li> newline style</li> <li> other linting</li> </ul> </li> </ul> <ol> <li> <p>Partially, no validation for them\u00a0\u21a9</p> </li> </ol>"},{"location":"layout/","title":"Layout","text":""},{"location":"layout/#memory-layout","title":"Memory Layout","text":"<p>The memory layout for the tree structure used by this library has the following properties:</p> <ul> <li>It is based on a contiguous memory slice.</li> <li>It is built in-place, as such children are placed directly after their parent.</li> <li>Attributes are immediately stored after a node.</li> <li>Pointers between nodes in the tree are not defined as absolute, but relative to the address of the current one.</li> <li>All strings are represented as string views over a common base offset which is valid for the whole tree.</li> </ul> <p>The structure of the various nodes is based on the size of three data types:</p> <ul> <li><code>delta_ptr_t</code> is the type of relative pointers. Realistically, 16bits is plenty enough for most realistic scenarios with XML files humans can handle.</li> <li><code>xml_size_t</code> is the type used to represent the size of nodes in bytes. It should be as high as the max size in byte a tree can have. 16bits is also often sufficient.</li> <li><code>xml_count_t</code> is the type used to represent the count of things. Like the number of attributes, or number of bytes in a string. Its size is mostly determined by the maximum length of strings_views. Depending on the application as low as 8bit could be enough, 16bit a more reasonable default.</li> <li><code>xml_enum_size_t</code> is the size of enums when stored. 8bit is plenty enough.</li> </ul> <p>Note</p> <p>If you have very specific needs for a compact memory layout, probably more suitable for embedded applications, you will have to manually override parts of this code and possibly work with bit-fields.  This goes beyond the configurability granted via macros, and forking this library is likely the best solution.</p>"},{"location":"layout/#binary-serialization","title":"Binary serialization","text":"<p>Except for a small header, the binary serialization of a tree is identical to its representation in memory.</p>"},{"location":"layout/#binary-format","title":"Binary format","text":"<p>TBW.</p>"},{"location":"modes/","title":"Modes","text":"<p>Builders are parametrized by a configuration structure and initialized in ways which defines its behaviour and ownership of data.</p>"},{"location":"modes/#configuration-fields","title":"Configuration fields","text":"<ul> <li><code>allow_comments</code> if true allows comments to be appended in the tree, else they are silently skipped (but can still throw exceptions for validation)</li> <li><code>allow_procs</code> if true allows processing directives to be appended in the tree, else they are silently skipped (but can still throw exceptions for validation)</li> <li><code>symbols</code>:<ul> <li><code>EXTERN_ABS</code> using full memory in absolute position; the generated tree cannot be saved as binary.</li> <li><code>EXTERN_REL</code> can be saved as binary, but it requires the tree to bind a symbol table later when constructed.</li> <li><code>OWNED</code> no compression of symbols, but they are owned.</li> <li><code>COMPRESS_LABELS</code> only compressing symbols which are used for tag and prop labels (and namespaces).</li> <li><code>COMPRESS_ALL</code> all symbols are compressed.</li> </ul> </li> <li><code>raw_strings</code> if true, strings are assumed to be kept as is when serialized or deserialized from XML. Make sure you manually escape those used in comparisons or to append further data.</li> </ul>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#installing","title":"Installing","text":"<p>Use it as a meson dependency, be it a subproject of after installing it on your system.  </p> <p>The process is basically as usual:</p> <pre><code>meson setup build           #Add more flags to setup release, lto optimizations etc based on your needs\nmeson install -C build      #You might have to define DESTDIR to perform a dry run or if you have a strange location\n</code></pre> <p>A simplified makefile is made available, which has some reasonable defaults.  </p> <p>Tarballs will also be offered for some distributions as part of future releases.  </p>"},{"location":"usage/#usage","title":"Usage","text":"<p>TBW</p>"}]}