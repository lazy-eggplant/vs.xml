{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Warning</p> <p>Ongoing project, not ready for release or usage yet. Many features are still missing.</p> <p>This library offers a mostly-compliant<sup>1</sup> XML parser, tree builder and several related utilities. It is not intended as a general purpose library, which means it might not be a good fit for your project. Please, read the rest of this readme for more information.  </p> <ol> <li> <p>XML 1.0 is covered as a best-effort, but there will be small things where either the official XML standard or this implementation is going to be incompatible or a superset.   For more information on compatibility, please check here.\u00a0\u21a9</p> </li> </ol>"},{"location":"compatibility/","title":"Compatibility","text":""},{"location":"compatibility/#standard-compatibility","title":"Standard compatibility","text":""},{"location":"compatibility/#features","title":"Features","text":""},{"location":"compatibility/#xml-parsing","title":"XML parsing","text":"<ul> <li> namespaces <sup>1</sup></li> <li> cdata<ul> <li> optional reduction to <code>text</code></li> </ul> </li> <li> text<ul> <li> optional merging of close text blocks</li> </ul> </li> <li> comments <ul> <li> optional stripping</li> </ul> </li> <li> basic entities</li> </ul>"},{"location":"compatibility/#tree-builder","title":"Tree builder","text":"<ul> <li> namespaces</li> <li> processing</li> <li> cdata</li> <li> text</li> <li> comments</li> </ul>"},{"location":"compatibility/#algorithms","title":"Algorithms","text":"<ul> <li> iterators for nodes</li> <li> iterators for attributes</li> <li> tree/sub-tree cloning<ul> <li> Basic copy</li> <li> String compression</li> </ul> </li> <li> attributes reordering</li> <li> node injection</li> <li> simplified tree wrapper to avoid xml::sv-&gt;string_view conversions.</li> </ul>"},{"location":"compatibility/#xml-serialization","title":"XML serialization","text":"<ul> <li> namespaces</li> <li> processing</li> <li> cdata</li> <li> text</li> <li> comments</li> <li> output configurability<ul> <li> indentation</li> <li> newline style</li> <li> other linting</li> </ul> </li> </ul> <ol> <li> <p>Partially, no validation for them\u00a0\u21a9</p> </li> </ol>"},{"location":"embedded/","title":"Embedded","text":"<p>Most usage of <code>libc++</code> is only related to header features, so it might be possible to introduce alternatives: - <code>libfmt</code> to cover <code>std::format</code> and <code>std::print</code>. - Some implementation for <code>std::vector</code>, <code>std::stack</code> and <code>std::unordered_map</code>.</p>"},{"location":"layout/","title":"Layout","text":"<p>The memory layout for the tree structure used by this library has the following properties: - It is based on a contiguous memory slice. - It is built in-place, as such children are placed directly after their parent. - Attributes are immediately stored after a node. - Pointers between nodes in the tree are not defined as absolute, but relative to the address of the current one. - All strings are represented as string views over a common base offset.</p> <p>The structure of the various nodes is based on the size of three data types:</p> <ul> <li><code>delta_ptr_t</code> is the type of relative pointers. Realistically, 16bits is plenty enough for most realistic scenarios with XML files humans can handle.</li> <li><code>xml_size_t</code> is the type used to represent the size of nodes in bytes. It should be as high as the max size in byte a tree can have. 16bits is also often sufficient.</li> <li><code>xml_count_t</code> is the type used to represent the count of things. Like the number of attributes, or number of bytes in a string. Its size is mostly determined by the maximum length of strings_views. Depending on the application as low as 8bit could be enough, 16bit a more reasonable default.</li> <li><code>xml_enum_size_t</code> is the size of enums when stored. 8bit is plenty enough.</li> </ul> <p>Note</p> <p>If you have very specific needs for a compact memory layout, probably more suitable for embedded applications, you will have to manually override parts of this code and possibly work with bit-fields.</p> <p>This goes beyond the configurability granted via macros, and forking this library is likely the best solution.</p>"}]}