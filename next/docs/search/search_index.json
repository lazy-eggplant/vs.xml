{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Warning</p> <p>Ongoing project, not ready for release or usage yet. Many features are still missing.</p> <p>This library offers a mostly-compliant<sup>1</sup> XML parser, tree builder and several related utilities. It is not intended as a general purpose library, which means it might not be a good fit for your project. Please, read the rest of this readme to know more about its objectives and drawbacks. Or continue reading this documentation for more in-depth topics.</p> <ol> <li> <p>XML 1.0 is covered as a best-effort, but there will be small things where either the official XML standard or this implementation is going to be incompatible or a superset.   For more information on compatibility, please check here.\u00a0\u21a9</p> </li> </ol>"},{"location":"benchmarks/","title":"Benchmarks","text":"<p><code>pugixml</code> is considered as baseline. These results are preliminary and will be replaced with a more formal benchmark suite, they are just intended to manage expectations correctly.  </p>"},{"location":"benchmarks/#parsing-xml","title":"Parsing XML","text":"<p>Moving from XML to the memory representation on the big dataset nasa_10_f_bs, skipping escaping/de-escaping (<code>raw_strings</code> true) and without managing symbols (<code>EXTERN_REL</code>), is around 0.45x the base throughput of <code>pugixml</code>. Different configurations, like <code>COMPRESSED_ALL</code> or even just <code>OWNED</code> are clearly going to be more expensive (twice as slow for the worst case observed compared to <code>EXTERN_REL</code>), but reducing the default types size has a positive impact (between 20 and 30% improvement observed over the original 0.45x).</p> <p>This is to be expected, as this library handles namespaces, has a higher memory footprint by default, and is forced to work with relative pointers throughout, which require some additional computation. So the slowdown is pretty tame overall, for what is intended as a rare operation. The expectation is that, once preprocessed, only the binary version of the original XML is going to be used.</p> <p>By comparison, loading the binary version is orders of magnitude faster due to the lazy loading as a memory mapped file. This is kind of cheating, but pugixml does not have a comparable feature, so I cannot do much about that. Even forcing a workload which requires access to the full buffer, this library when loading the binary is about 1.2 times the base pugixml speed. This is in a worst-case memory footprint, reducing the default data types will improve performance as disk access is reduced.  </p> <p>A more valid measure of performance will depend on the workload, and is going to be considered in a separate section.</p>"},{"location":"benchmarks/#saving-as-xml","title":"Saving as XML","text":"<p>Unsurprisingly, this is where <code>vs.xml</code> is weak by comparison. It is around 10% of pugixml speed. This is mostly due to my poor implementation but also the underwhelming performance of <code>std::format</code>. Moving to <code>fmt::format</code> we are now around 27% of pugixml speed, which is quite a bump. This metric will be surely improved as there is no good reason for it to be this bad, but XML serialization is not meant as a common operation for the scope of the library, so this result is not very impactful.</p>"},{"location":"benchmarks/#tree-construction","title":"Tree construction","text":"<p>To be tested.</p>"},{"location":"benchmarks/#filtering-searching","title":"Filtering &amp; searching","text":"<p>To be tested.</p>"},{"location":"configuration/","title":"Configuration","text":""},{"location":"configuration/#meson-project","title":"Meson project","text":"<ul> <li><code>tests</code> defaults to false. Change to enable test-suite.</li> <li><code>benchmarks</code> defaults to false. Change to enable benchmarks.</li> <li><code>examples</code> defaults to false. Change to enable examples.</li> <li><code>utils</code> defaults to true. Change to compile the extra system utilities.</li> <li><code>use_fmt</code> defaults to true. Disable if you want to force using <code>std::print</code>/<code>std::format</code> instead, but be mindful they are much slower.</li> </ul>"},{"location":"configuration/#defines","title":"Defines","text":"<ul> <li><code>VS_XML_NS</code> defaults to <code>xml</code>. Changes the namespace if needed, to avoid collisions.</li> <li><code>VS_XML_NOASSERT</code> not implemented</li> <li><code>VS_XML_NOEXCEPT</code> not implemented</li> </ul>"},{"location":"configuration/#data-types-layout","title":"Data types &amp; Layout","text":"<p>The memory layout for the tree structure used by this library has the following properties:</p> <ul> <li>It is based on a contiguous memory slice.</li> <li>It is built in-place, as such children are placed directly after their parent.</li> <li>Attributes are immediately stored after a node.</li> <li>Pointers between nodes in the tree are not defined as absolute, but relative to the address of the current one.</li> <li>All strings are represented as string views over a common base offset which is valid for the whole tree.</li> </ul> <p>The structure of the various nodes is based on the size of three data types:</p> <ul> <li><code>delta_ptr_t</code> is the type of relative pointers. Realistically, 16bits is plenty enough for most realistic scenarios with XML files humans can handle.</li> <li><code>xml_size_t</code> is the type used to represent the size of nodes in bytes. It should be as high as the max size in byte a tree can have. 16bits is also often sufficient.</li> <li><code>xml_count_t</code> is the type used to represent the count of things. Like the number of attributes, or number of bytes in a string. Its size is mostly determined by the maximum length of strings_views. Depending on the application as low as 8bit could be enough, 16bit a more reasonable default.</li> <li><code>xml_enum_size_t</code> is the size of enums when stored. 8bit is plenty enough.</li> </ul> <p>Note</p> <p>If you have very specific needs for a compact memory layout, probably more suitable for embedded applications, you will have to manually override parts of this code and possibly work with bit-fields.  This goes beyond the configurability granted via macros, and forking this library is likely the best solution.</p>"},{"location":"configuration/#builder","title":"Builder","text":"<p>Builders are parametrized by a configuration structure and initialized in ways which defines its behaviour and ownership of data.</p>"},{"location":"configuration/#configuration-fields","title":"Configuration fields","text":"<ul> <li><code>allow_comments</code> if true allows comments to be appended in the tree, else they are silently skipped (but can still throw exceptions for validation)</li> <li><code>allow_procs</code> if true allows processing directives to be appended in the tree, else they are silently skipped (but can still throw exceptions for validation)</li> <li><code>symbols</code>:<ul> <li><code>EXTERN_ABS</code> using full memory in absolute position; the generated tree cannot be saved as binary.</li> <li><code>EXTERN_REL</code> can be saved as binary, but it requires the tree to bind a symbol table later when constructed.</li> <li><code>OWNED</code> no compression of symbols, but they are owned.</li> <li><code>COMPRESS_LABELS</code> only compressing symbols which are used for tag and prop labels (and namespaces).</li> <li><code>COMPRESS_ALL</code> all symbols are compressed.</li> </ul> </li> <li><code>raw_strings</code> if true, strings are assumed to be kept as is when serialized or deserialized from XML. Make sure you manually escape those used in comparisons or to append further data.</li> </ul>"},{"location":"faq/","title":"Faq","text":"<p>Why the binary serialization of the XML is bigger compared to the base file?</p> <p>That is to be expected. XML has very little overhead, with extra symbols and marker. By comparison, nodes as represented by this library are storing contextual information about their neighbours to speed up navigation. This additional pre-computed information explains the bigger size. Even when compressed via gzip, the source XML retains a meaningful edge.  </p> <p>So, why should I save the binary serialization?</p> <p>Because you don\u2019t need to parse the file after the first time. You just need to memory-map it and use it as is. This lowers start-up time quite a bit and gives you constant access to its content regardless of size.</p> <p>What is the point of a representation which is not mutable? Why cannot I edit the tree?</p> <p>Technically it is not immutable; however some types of mutations would be very expensive, almost like rebuilding the tree from scratch. Still, there are some which are quite fast, like reordering attributes, changing value with literals which are already in memory, or adding annotations to mark changes. Some of them are implemented by this library, others could be in a nearby future.  </p> <p>As for why, there is plenty of applications where a mutable tree structure is no longer needed after it has being built. This library tries to optimize such cases without introducing features which could compromise them.</p> <p>Why pointers are internally represented as relative to a base?</p> <p>To allow them to be serialized, and still provide random access to the tree regardless of the device or medium on which it is being stored. This allows to share annotations for a tree for cheap, even while offloading or distributing computation.</p> <p>Why is XML serialization/de-serialization single threaded?</p> <p>Because they are mostly meant as one-time operations, while the bulk of the operations is going to be on the binary representation. There is no trivial way to make XML parsing or serialization \u201cparallel\u201d without making the code involved much more complex. At which point it is generally better to waste threads for other tasks if possible.</p>"},{"location":"features/","title":"Features","text":""},{"location":"features/#standard-compatibility","title":"Standard compatibility","text":""},{"location":"features/#features","title":"Features","text":""},{"location":"features/#xml-parsing","title":"XML parsing","text":"<ul> <li> namespaces <sup>1</sup></li> <li> cdata<ul> <li> optional reduction to <code>text</code></li> </ul> </li> <li> text<ul> <li> optional merging of close text blocks</li> </ul> </li> <li> comments <ul> <li> optional stripping</li> </ul> </li> <li> basic entities</li> <li> complex entities</li> </ul>"},{"location":"features/#tree-builder","title":"Tree builder","text":"<ul> <li> namespaces</li> <li> processing</li> <li> cdata</li> <li> text</li> <li> comments</li> </ul>"},{"location":"features/#algorithms","title":"Algorithms","text":"<ul> <li> iterators for nodes</li> <li> iterators for attributes</li> <li> tree/sub-tree cloning<ul> <li> Basic copy</li> <li> String compression</li> </ul> </li> <li> attributes reordering</li> <li> node injection</li> <li> simplified tree wrapper to avoid xml::sv-&gt;string_view conversions.</li> </ul>"},{"location":"features/#xml-serialization","title":"XML serialization","text":"<ul> <li> namespaces</li> <li> processing</li> <li> cdata</li> <li> text</li> <li> comments</li> <li> output configurability<ul> <li> indentation</li> <li> newline style</li> <li> other linting</li> </ul> </li> </ul> <ol> <li> <p>Partially, no validation for them\u00a0\u21a9</p> </li> </ol>"},{"location":"formats/","title":"Formats","text":""},{"location":"formats/#memory-layout","title":"Memory Layout","text":""},{"location":"formats/#binary-serialization","title":"Binary serialization","text":"<p>Except for a small header, the binary serialization of a tree is identical to its representation in memory.</p>"},{"location":"formats/#binary-format","title":"Binary format","text":"<p>TBW.</p>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#installing","title":"Installing","text":"<p>Use it as a meson dependency, be it a subproject of after installing it on your system.  </p> <p>The process is basically as usual:</p> <pre><code>meson setup build           #Add more flags to setup release, lto optimizations etc based on your needs\nmeson install -C build      #You might have to define DESTDIR to perform a dry run or if you have a strange location\n</code></pre> <p>A simplified makefile is made available, which has some reasonable defaults.  </p> <p>Tarballs will also be offered for some distributions as part of future releases.  </p>"},{"location":"usage/#usage","title":"Usage","text":"<p>TBW</p>"},{"location":"usage/#configuration","title":"Configuration","text":"<p>Read this.</p>"},{"location":"usage/#integration-examples","title":"Integration examples","text":""},{"location":"usage/#external-index","title":"External index","text":""},{"location":"usage/#containers-ranges","title":"Containers &amp; ranges","text":""},{"location":"usage/#performing-queries","title":"Performing queries","text":""}]}