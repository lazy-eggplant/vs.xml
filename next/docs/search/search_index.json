{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Warning</p> <p>Ongoing project. Many features are still missing and documentation has not a full coverage.</p> <p>This library offers a mostly-compliant<sup>1</sup> XML parser, tree builder, query engine and several related utilities. It is not intended as a general purpose library, which means it might not be a good fit for your project. Please, read the rest of the original readme to know more about its objectives and drawbacks. Or continue with this documentation which offers a more in-depth description of several topics.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Support for a schema-less tree structure which can be fully relocated in disk, memory or offloaded devices without impacting its binary representation.</li> <li>Linked to the previous point, pointers/iterators based on this tree structure are random access, no need to navigate the tree to reach them.</li> <li>Good memory locality of the tree representation, making many operations on sub-trees trivial <code>memcpy</code>.</li> <li>Configurable memory footprint, the internal representation can decrease size for most of its fields properly run on \u201clesser\u201d systems or improve cache performance.</li> <li>An efficient engine to perform queries on a document, all based on lazy evaluation.</li> <li>XML serialization and de-serialization.</li> <li>Naive support for namespaces<sup>2</sup>.</li> </ul> <p>Non objectives:</p> <ul> <li>Support for arbitrary editing operations. This library is special-purpose, so only a small number of mutable operations will be supported to keep the rest as fast as possible.</li> <li>Extended XML entities, base64, DTD\u2026 none of that is needed for the intended target of this library.</li> <li>In general, being fully XML compliant.</li> </ul> <ol> <li> <p>XML 1.0 is covered as a best-effort, but there will be small things where either the official XML standard or this implementation is going to be incompatible or a superset.   For more information on compatibility, please check here.\u00a0\u21a9</p> </li> <li> <p>Namespaces are supported in the sense that the namespace is split from the element or attribute name if present, but its handling, validation or whatever is left to the user.\u00a0\u21a9</p> </li> </ol>"},{"location":"architecture/","title":"Architecture","text":""},{"location":"architecture/#trees-documents-archives","title":"Trees, Documents, Archives","text":""},{"location":"architecture/#tree","title":"Tree","text":"<p>A tree is defined by a single root node. There are several types of nodes, reflecting those we have in XML files:</p> <ul> <li>element</li> <li>cdata</li> <li>text</li> <li>comment</li> <li>processing directive</li> </ul> <p>Each element can have an arbitrary number of attributes and children nodes. The rest of them only host a view/span for their content. Please, notice that while text and cdata are kept separate to preserve the original XML structure, once deserialized in memory there is no real difference amongst them.  </p> <p>There is also a special node type: markers. These are not part of the basic XML specs, and are only used internally to support downstream algorithms and data structure to annotate, extend or index the tree structure.  </p> <p>Labels, symbols and strings in general, are not inlined with the tree structure itself, but they are hosted in a separate symbol table. In some modes, this can be the original XML file itself, or a special buffer filled in with strings based on some compression method to reuse entries.</p>"},{"location":"architecture/#document","title":"Document","text":"<p>Documents wrappers of tree to allow full XML documents. While an XML document only has one root element, there can be multiple processing directives (starting with <code>&lt;?xml ... ?&gt;</code> itself) and comments. Documents are just going to enable that.</p>"},{"location":"architecture/#archive","title":"Archive","text":"<p>Archives are collections of documents. Each can be optionally given a name. Unlike documents, where each can have its own symbol table, there is just one per archive, shared across its nested documents.</p>"},{"location":"architecture/#storageforstored","title":"<code>StorageFor</code>/<code>Stored</code>","text":""},{"location":"architecture/#class-vs-classraw","title":"<code>Class</code> vs <code>ClassRaw</code>","text":"<p><code>Class</code> is a wrapper for <code>ClassRaw</code>. In exchange for some performance and a slight increase in memory, it keeps better track of contextual information. This simplifies the usage of relative string views and the general navigation of the tree structure.  </p> <p>In practice, you can just use <code>Class</code> over <code>ClassRaw</code> for virtually any scenario. In case the nice extras provided are really, really not needed, the raw base class will give you a small memory bonus.</p>"},{"location":"architecture/#builders","title":"Builders","text":""},{"location":"architecture/#parser","title":"Parser","text":""},{"location":"architecture/#serialization","title":"Serialization","text":""},{"location":"architecture/#queries","title":"Queries","text":""},{"location":"architecture/#binary-formats","title":"Binary formats","text":""},{"location":"configuration/","title":"Configuration","text":"<p>For performance reasons, most configuration flags are defined at compile-time. A single application will have to build and link different versions of this library if they want different configurations, but that scenario is extremely unlikely.</p>"},{"location":"configuration/#meson-project","title":"Meson project","text":"<ul> <li><code>tests</code> defaults to false. Change to enable test-suite.</li> <li><code>benchmarks</code> defaults to false. Change to enable benchmarks.</li> <li><code>examples</code> defaults to false. Change to enable examples.</li> <li><code>utils</code> defaults to true. Change to compile the extra system utilities.</li> <li><code>use_fmt</code> defaults to true. Disable it if you want to force using <code>std::print</code>/<code>std::format</code> instead, but be mindful they are much slower.</li> <li><code>use_gtl</code> defaults to false. Enable it to use alternative STL-like containers with better performance and memory-mappability (is that even a word?).</li> <li><code>noexcept</code> defaults to false. Used to disable exceptions from the build. Often needed for embedded or offloaded targets.</li> </ul>"},{"location":"configuration/#defines","title":"Defines","text":"<ul> <li><code>VS_XML_NS</code> defaults to <code>xml</code>. Changes the namespace if needed, to avoid collisions.</li> <li><code>VS_XML_NO_ASSERT</code> to remove assertions from this library.</li> <li><code>VS_XML_NO_EXCEPT</code> to remove exceptions from this library as much as possible.</li> <li><code>VS_XML_LAYOUT</code> is used to control the memory layout (defaults to 0). Current profiles:<ul> <li><code>0</code> Normal/aligned</li> <li><code>1</code> Compact (mostly compatible with real world documents, less cache-misses, less space on disk)</li> </ul> </li> </ul>"},{"location":"configuration/#data-types-layout","title":"Data types &amp; Layout","text":"<p>The memory layout for the tree structure used by this library has the following properties:</p> <ul> <li>It is based on a contiguous memory slice.</li> <li>It is built in-place, as such children are placed directly after their parent.</li> <li>Attributes are immediately stored after a node.</li> <li>Pointers between nodes in the tree are not defined as absolute, but relative to the address of the current one.</li> <li>All strings are represented as string views over a common base offset which is valid for the whole tree.</li> </ul> <p>The structure of the various nodes is based on the size of three data types:</p> <ul> <li><code>delta_ptr_t</code> is the type of relative pointers. Realistically, 16bits is plenty enough for most realistic scenarios with XML files humans can handle.</li> <li><code>xml_size_t</code> is the type used to represent the size of nodes in bytes. It should be as high as the max size in byte a tree can have. 16bits is also often sufficient.</li> <li><code>xml_count_t</code> is the type used to represent the count of things. Like the number of attributes, or number of bytes in a string. Its size is mostly determined by the maximum length of strings_views. Depending on the application as low as 8bit could be enough, 16bit a more reasonable default.</li> <li><code>xml_enum_size_t</code> is the size of enums when stored. 8bit is plenty enough.</li> </ul> <p>Note</p> <p>If you have very specific needs for a compact memory layout, probably more suitable for embedded applications, you will have to manually override parts of this code and possibly work with bit-fields. This goes beyond the configurability granted via macros, and forking this library is likely the best option.</p>"},{"location":"configuration/#builder","title":"Builder","text":"<p>Builders are parametrized by a configuration structure and initialized in ways which defines its behaviour and ownership of data.</p>"},{"location":"configuration/#configuration-fields","title":"Configuration fields","text":"<ul> <li><code>allow_comments</code> if true allows comments to be appended in the tree, else they are silently skipped (but can still return errors for validation)</li> <li><code>allow_procs</code> if true allows processing directives to be appended in the tree, else they are silently skipped (but can still return errors for validation)</li> <li><code>symbols</code>:<ul> <li><code>EXTERN_ABS</code> using full memory in absolute position; the generated tree cannot be saved as binary.</li> <li><code>EXTERN_REL</code> can be saved as binary, but it requires the tree to bind a symbol table later when constructed.</li> <li><code>OWNED</code> no compression of symbols, but they are owned.</li> <li><code>COMPRESS_LABELS</code> only compressing symbols which are used for tag and prop labels (and namespaces).</li> <li><code>COMPRESS_ALL</code> all symbols are compressed.</li> <li><code>COMPRESS_CUSTOM</code> not implemented yet. Used to determine the usage of a custom compression algorithm, offloading it from the library.     Useful to specify your own for embedded systems or to implement more expensive but compressed representations.</li> </ul> </li> <li><code>raw_strings</code> if true, strings are assumed to be preserved as is when serialized or deserialized from XML.   Make sure you are manually escaping when building the tree. Comparisons on the other hand will handle the conversion automatically when not using the <code>xxxRaw</code> versions of the library classes.</li> </ul>"},{"location":"embedded/","title":"Embedded","text":"<p>A subset of features of this library is embedded-friendly or there is an active effort in making them such. This usually implies:</p> <ul> <li>It operates without requiring exceptions (mostly replaced by <code>std::optional</code> and <code>std::expected</code>).</li> <li>It does not require dynamic memory allocations, or when they are needed, allocation events are kept to a minimum. More on this later.</li> <li>The tree structures can be scaled down considerably in size, to better match type sizes which are compatible with the target system.</li> <li>Lightweight usage of the STL, no runtime features needed. In many cases, the STL can be replaced with different libraries via configuration flags.</li> </ul>"},{"location":"embedded/#usage","title":"Usage","text":"<p>A basic build could look like this:</p> <pre><code>meson setup build-emb --native-file=./platforms/gcc-embedded.ini -Dnoexcept=true -Dutils=false\n</code></pre> <p>It is important to enable the <code>noexcept</code> flag and disable <code>utils</code> alongside any other optional module. </p>"},{"location":"embedded/#features","title":"Features","text":""},{"location":"embedded/#features-optimized-for-embedded","title":"\ud83d\udfe2 Features optimized for embedded","text":"<ul> <li><code>TreeRaw</code>/<code>Tree</code> general usage</li> <li><code>DocumentRaw</code>/<code>Document</code> general usage</li> <li><code>ArchiveRaw</code>/<code>Archive</code> general usage</li> <li>The XML parser when <code>.raw_strings=true</code>, however wraps builders which are not fully optimized yet.</li> <li>Memos/notes/indices can all be implemented externally, as long as you have a proper library for containers <code>vs.xml</code> will not get in your way.</li> </ul>"},{"location":"embedded/#features-planned-for-embedded","title":"\ud83d\udfe0 Features planned for embedded","text":"<ul> <li><code>TreeBuilder</code> &amp; <code>DocumentBuilder</code>. Right now they own their storage, unable to just work on externally defined ones and memory allocations are needed to build archives.   It is possible to reserve space limiting allocations, but they cannot be fully removed.</li> <li>The XML serializer when <code>.raw_strings=true</code>, it is still using functions which are not optimized, but their replacement has been implemented already. It also assumes to operate on a stream which is not great.</li> <li>The <code>QueryBuilder</code>, same notes as for the other builders.</li> <li>Queries. Right now they are not good due to the high number of dynamic allocations needed. They could be trivially removed for the most part, but the whole system is being refactored to be stack-based and consume less memory overall.</li> </ul>"},{"location":"embedded/#features-not-planned-for-embedded","title":"\ud83d\udd34 Features not planned for embedded","text":"<ul> <li>The utilities shipped alongside this library are not meant for embedded usage.</li> <li>Most of the test-suite. Embedded will feature its own subset of tests and benchmarks.</li> </ul>"},{"location":"embedded/#storage-handling","title":"Storage handling","text":"<p>If you want to avoid memory allocations, please make use of the original Tree/Document/Archive in place of their wrappers in <code>xml::stored</code> as you might see suggested in several examples. The originals don\u2019t own their memory, so you can externally manage it as you prefer.</p>"},{"location":"faq/","title":"Faq","text":"<p>Why the binary serialization of the XML is bigger compared to the base file?</p> <p>That is to be expected. XML has very little overhead, with very little in terms of extra symbols and markers. By comparison, this library represents nodes by storing contextual information about their neighbours to speed up navigation. This additional pre-computed information explains the bigger memory footprint. Even when compressed via gzip, the source XML retains a meaningful edge.  </p> <p>So, why should I save the binary serialization?</p> <p>Because you don\u2019t need to parse the original file again. You just need to memory-map it and use it as is. This lowers start-up time quite to zero if using <code>mmap</code>, and will only load pages for the content you need, regardless of the original file size. Such approach can massively boot real world performance on huge files, but also positively impact smaller ones as it operates lazily.</p> <p>What is the point of a representation which is not mutable? Why cannot I edit the tree?</p> <p>Technically it is not immutable; however some types of mutations would be very expensive, almost like rebuilding the entire tree from scratch. Still, there are some operations which are quite fast, like reordering attributes in-place, changing strings with symbols already stored in memory, or adding annotations to the original document. Some of these operations are implemented by this library, others could be in a nearby future or delegated to downstream integrations.  </p> <p>As for why, there is plenty of applications where mutability of the tree structure is only needed during construction, and only for the next token to append. This library tries to optimize such cases without introducing features which could compromise their performance.</p> <p>Why pointers are internally represented as relative to a base?</p> <p>To allow them to be serialized, and still provide random access to the tree regardless of the device or medium on which it ends up being stored. This allows to share annotations of a tree for cheap, even while offloading or distributing computation. Also, results of complex queries are fully portable and easy to share.</p> <p>Why is XML serialization/de-serialization single threaded?</p> <p>Simple answer, laziness. A more serious reply would be that serialization and de-serialization are meant to be just one-off operations. The bulk of whatever computation we must perform is going to act on the binary representation, not the original text. There is no trivial way to make XML parsing or serialization \u201cparallel\u201d without making the code involved much more complex. At which point it is generally better to waste threads for other tasks if possible.</p> <p>How to annotate a tree?</p> <p>References to XML nodes and attributes have a method <code>addr</code> to return their portable address. Keeping a hash map or a similar data structure does the trick. You should be using a data structure which can be easily serialized/de-serialized, or even better which can be memory-mapped if feasible. The standard C++ library is not your best option, you might want to check for alternative like gtl.</p> <p>How to cache queries?</p> <p>At the moment this is not directly supported by the library and will likely never be. However, we plan to introduce features to make it easier on downstream code. Right now, queries are not trivially hash-able. At some point we will add a query builder to structure query trees into linear buffers, more or less like we do with XML. The evolving plans for this feature are reported in a specifications document. Until then, a similar solution has to be implemented fully downstream.</p> <p>How to serialize/deserialize attributes of text fields into a different data type, like integers or floating point numbers?</p> <p>XML has no intrinsic concept of \u201cserialized data\u201d. All attributes and text values are string_views. We have schema languages built on top of XML, like RelaxNG. They usually allow annotating types for fields, but it has nothing to do with XML; hence, this library will not handle that. However, there are some intended workarounds: - The symbol table can pretty much fit whatever the user\u2019s want. String views are not null terminated.   So, building a tree with <code>.raw_strings=true</code> would allow for arbitrary data, as long as no attempt is made to serialize the tree to XML from its binary representation. - It is possible to represent the de-serialized values as annotations over tree nodes, and store them into a map-like container.   Those could either be saved alongside the original file (good if the serialization/de-serialization process is complex), or just generated when needed just to be cached for a faster retrieval.</p>"},{"location":"features/","title":"Features","text":""},{"location":"features/#standard-compatibility","title":"Standard compatibility","text":""},{"location":"features/#xml-parsing","title":"XML parsing","text":"<ul> <li> namespaces <sup>1</sup></li> <li> cdata</li> <li> text<ul> <li> Unified iterator for text of an element, scanning all text/CDATA children.</li> </ul> </li> <li> comments <ul> <li> optional stripping</li> </ul> </li> <li> basic entities</li> <li> complex entities</li> </ul>"},{"location":"features/#xml-serialization","title":"XML serialization","text":"<ul> <li> namespaces</li> <li> processing</li> <li> cdata</li> <li> text</li> <li> comments</li> <li> output configurability<ul> <li> indentation</li> <li> newline style</li> <li> other linting</li> </ul> </li> </ul>"},{"location":"features/#library-features","title":"Library features","text":""},{"location":"features/#tree-builder","title":"Tree builder","text":"<ul> <li> namespaces</li> <li> processing</li> <li> cdata</li> <li> text</li> <li> comments</li> </ul>"},{"location":"features/#algorithms","title":"Algorithms","text":"<ul> <li> iterators for nodes</li> <li> iterators for attributes</li> <li> tree/sub-tree cloning<ul> <li> Basic copy</li> <li> String compression</li> </ul> </li> <li> attributes reordering</li> <li> node injection</li> <li> simplified tree wrapper to avoid xml::sv-&gt;string_view conversions.</li> </ul>"},{"location":"features/#queries","title":"Queries","text":""},{"location":"features/#portability","title":"Portability","text":"<ul> <li> <code>noexcept</code> mode</li> <li> <code>noassert</code> mode</li> <li> no memory allocations<ul> <li> for the tree/documents binary representation</li> <li> in the query builder<sup>2</sup></li> <li> in tree building<sup>2</sup></li> <li> in query processing<sup>3</sup></li> </ul> </li> </ul> <ol> <li> <p>Partially, no validation for them\u00a0\u21a9</p> </li> <li> <p>The objective is to pass custom allocators so that arena strategies can be implemented for example.\u00a0\u21a9\u21a9</p> </li> <li> <p>Queries allocates as a stack, so specific strategies and allocator can be adopted for them.\u00a0\u21a9</p> </li> </ol>"},{"location":"offloading/","title":"Offloading","text":"<p>TBW</p>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#installing","title":"Installing","text":"<p>This library is meant to be use either as a system dependency, or as a meson subproject. The second option will grant you more flexibility in case you need control over the memory layout or other configuration flags.  </p> <p>To our knowledge, this library is not distributed by any distribution. To install it on your system you will probably want to write something like:</p> <pre><code>meson setup build           #You might want to introduce more flags to setup the build type to release, lto optimizations et cetera.\nmeson install -C build      #You might want to define DESTDIR before to perform a semi-dry run.\n</code></pre> <p>A simplified makefile is made available, which has some reasonable defaults, but uses meson under the hood.  </p> <p>Tarballs will also be offered for some distributions as part of future releases.  </p>"},{"location":"usage/#as-a-dependency","title":"As a dependency","text":"<p>Feel free to use this as baseline for your wrap file:</p> <pre><code>[wrap-git]\nurl = https://github.com/lazy-eggplant/vs.xml\nrevision = v0.2.5   #Make sure to use the latest\ndepth = 1\nmethod = meson\n[provide]\nvs_xml = vs_xml_dep\n</code></pre>"},{"location":"usage/#configuration","title":"Configuration","text":"<p>Read this document about configuration.</p>"},{"location":"usage/#examples","title":"Examples","text":"<p>Please, refer to the <code>examples</code> folder to see this library in action.</p>"},{"location":"benchmarks/baseline-test/","title":"Baseline test","text":"<p><code>pugixml</code> is considered as baseline. These results are preliminary and will be replaced with a more formal benchmark suite, they are just intended to manage expectations correctly.  </p>"},{"location":"benchmarks/baseline-test/#parsing-xml","title":"Parsing XML","text":"<p>Moving from XML to the memory representation on the big dataset nasa_10_f_bs, skipping escaping/de-escaping (<code>raw_strings</code> true) and without managing symbols (<code>EXTERN_REL</code>), is around 0.45x the base throughput of <code>pugixml</code>. Different configurations, like <code>COMPRESSED_ALL</code> or even just <code>OWNED</code> are clearly going to be more expensive (twice as slow for the worst case observed compared to <code>EXTERN_REL</code>), but reducing the default types size has a positive impact (between 20 and 30% improvement observed over the original 0.45x).</p> <p>This is to be expected, as this library handles namespaces, has a higher memory footprint by default, and is forced to work with relative pointers throughout, which require some additional computation. So the slowdown is pretty tame overall, for what is intended as a rare operation. The expectation is that, once preprocessed, only the binary version of the original XML is going to be used.</p> <p>By comparison, loading the binary version is orders of magnitude faster due to the lazy loading as a memory mapped file. This is kind of cheating, but pugixml does not have a comparable feature, so I cannot do much about that. Even forcing a workload which requires access to the full buffer, this library when loading the binary is about 1.2 times the base pugixml speed. This is in a worst-case memory footprint, reducing the default data types will improve performance as disk access is reduced.  </p> <p>A more valid measure of performance will depend on the workload, and is going to be considered in a separate section.</p>"},{"location":"benchmarks/baseline-test/#saving-as-xml","title":"Saving as XML","text":"<p>Unsurprisingly, this is where <code>vs.xml</code> is weak by comparison. It is around 10% of pugixml speed. This is mostly due to my poor implementation but also the underwhelming performance of <code>std::format</code>. Moving to <code>fmt::format</code> we are now around 27% of pugixml speed, which is quite a bump. This metric will be surely improved as there is no good reason for it to be this bad, but XML serialization is not meant as a common operation for the scope of the library, so this result is not very impactful.</p>"},{"location":"benchmarks/baseline-test/#tree-construction","title":"Tree construction","text":"<p>To be tested.</p>"},{"location":"benchmarks/baseline-test/#filtering-searching","title":"Filtering &amp; searching","text":"<p>To be tested.</p>"},{"location":"examples/","title":"Index","text":"<p>Right now this part of the documentation has next to no content. Please, also check the <code>examples</code> folder in the repository for full code.</p>"},{"location":"examples/complex-queries/","title":"Complex queries","text":""},{"location":"examples/complex-queries/#tbw","title":"TBW","text":""},{"location":"examples/memory-mapping/","title":"Memory mapping","text":""},{"location":"examples/memory-mapping/#what-is-memory-mapping","title":"What is memory mapping?","text":""},{"location":"examples/memory-mapping/#using-mio","title":"Using <code>mio</code>","text":""},{"location":"examples/memory-mapping/#loading-file","title":"Loading file","text":""},{"location":"examples/memory-mapping/#saving-file","title":"Saving file","text":""},{"location":"examples/memory-mapping/#mutable-operations","title":"Mutable operations?","text":""},{"location":"examples/optimization/","title":"Optimization","text":""},{"location":"examples/optimization/#embedded-applications","title":"Embedded applications","text":""},{"location":"examples/optimization/#disable-exceptions","title":"Disable exceptions","text":""},{"location":"examples/optimization/#limit-memory-allocations","title":"Limit memory allocations","text":""},{"location":"examples/shared-symbols/","title":"Shared symbols","text":""},{"location":"examples/shared-symbols/#reusing-symbols","title":"Reusing symbols","text":""},{"location":"examples/shared-symbols/#archives","title":"Archives","text":""},{"location":"examples/simple-builders/","title":"Simple builders","text":""},{"location":"examples/simple-builders/#building-a-tree","title":"Building a tree","text":""},{"location":"examples/simple-builders/#building-a-document","title":"Building a document","text":""},{"location":"examples/simple-builders/#saving-to-xml","title":"Saving to XML","text":""},{"location":"examples/simple-builders/#saving-to-binary","title":"Saving to binary","text":""},{"location":"examples/simple-loading/","title":"Simple loading","text":""},{"location":"examples/simple-loading/#basic-xml-parsing","title":"Basic XML parsing","text":""},{"location":"examples/simple-loading/#simple-queries","title":"Simple queries","text":""},{"location":"releases/v0.2.1/","title":"V0.2.1","text":"<p>Release to propagate (the minor) breaking changes downstream. We don\u2019t have many new features visible, but a lot of work in the background to improve the code base and its scope. For reference, <code>v0.2.x</code> should provide as main features: </p> <ul> <li>Queries</li> <li>Multiple documents sharing symbols (and related binary format)</li> <li>Helpers for annotations (but they might be rescheduled for <code>v0.3.x</code> based on how much feature creep is met as it relates to tree injection which is its own beast to handle)</li> </ul> <p>As minor features:</p> <ul> <li>Support for iterators to visit text across <code>text</code> and <code>cdata</code> boundaries.</li> <li>Apply replacement for serialization functions which don\u2019t use memory allocations in the serialization code (already implemented, not used)</li> </ul> <p>Several steps have been made to implement both, but they cannot be tested still (probably there will be queries mostly done in v0.2.3).</p>"},{"location":"releases/v0.2.1/#changes","title":"Changes","text":"<ul> <li>Removed virtually all explicit exceptions.</li> <li>Removed memory allocations for a wide range of operations.</li> <li>Improvements to the binary format.</li> <li>Initial work to support shared symbol tables, annotations and queries. </li> <li>More entry-points for customization, like some containers or predefined reduced memory layouts.</li> <li>Structural improvements in the repo, code quality etc.</li> </ul>"},{"location":"releases/v0.2.1/#breaking-features","title":"Breaking features","text":"<ul> <li>The binary format changed.</li> <li>Several functions had some minor changes, like <code>[[nodiscard]]</code> being added, or <code>std::expected</code> in place of exceptions.</li> </ul>"},{"location":"releases/v0.2.5/","title":"V0.2.5","text":"<p>This release is very dense release in terms of features! Most of them have been under development for a while, but they just about reached the \u201cuntested but useful\u201d state:</p> <ul> <li>Queries on the XML tree are now working! With shorthands and everything. They need a good documentation page as they are one of the core features to properly use this library.</li> <li>(breaking) changes in the binary format to support multi-document archives sharing symbols. No capability exposed to the library yet, but the binary format should be \u201cfinal\u201d.</li> <li>The configuration flags used while configuring the project are now shipped with the library headers.</li> <li>A new <code>text</code> iterator to access all <code>text</code> and <code>cdata</code> sections of an element in one go. It is kind of slow compared to direct access of the string-view.  </li> </ul> <p>For some operations, filtering text/cdata children and iterate over their values will be a much better approach compared to the new <code>text</code>. Still, it can be good for queries or to implement searches.</p>"},{"location":"releases/v0.2.5/#notice-on-future-query-redesign","title":"Notice on future query redesign","text":"<p>TLDR: The overall high level syntax will be kept, but the underlying implementation will be replaced.</p> <p>This first implementation of queries was very informative and technically functional\u2026 but also very annoying to work with. It is plagued by issues linked to object lifetimes, which are not as easy to unravel due to the presence of co-routines in the mix. By the way, coroutines in C++ are nice to use but quite bad in terms of memory footprint for this application, and while mitigations are possible, memory is going to be higher compared to an iterator-based approach.  </p> <p>Furthermore, we don\u2019t have properly serializable queries with simple hashing\u2026 So, for the next release, it will be time to decide what was good about this first implementation and what to do so that the experience of the next is going to be better.  </p> <ul> <li>Design queries to work with the query builder, not as an afterthought but since the very beginning. The design work being done in here must be extended.</li> <li>Drop co-routines. They were good to sketch a quick working solution, they are awful to harden against memory allocations and when handling issues related to their memory footprint.</li> <li>Keep the high level syntax the same, it is actually quite good I think.</li> </ul>"},{"location":"releases/v0.2.9/","title":"V0.2.9","text":"<p>Surprisingly little changed in this release for the final users, but many changes have been made to ensure this library is more suitable in embedded applications. Trees, documents and archives no longer handle their memory directly, allowing for their external allocation. Wrappers still owning memory are available in <code>xml::stored</code> under the same name as their original versions. The namespace will be made unavailable when compiling for an embedded or offloaded target in a later release.  </p> <p>Next release will focus on documentation, examples, better handling of embedded/offloaded targets, and will start refactoring the code handling queries to match the current objectives.</p>"},{"location":"releases/v0.2.9/#breaking-changes","title":"Breaking changes","text":"<ul> <li>The <code>close</code> function for Tree(Raw) and Document(Raw) changed signature to return the new <code>Stored&lt;T&gt;</code> objects, so that storage is separate from the base classes to better use code in embedded and offloaded contexts. </li> <li>The <code>close_fragment</code> and <code>extract_symbols</code> functions changed. The former now returns a data type more compatible with the revised Archive sections, while the latter has been extended to return both symbols and buffer at once.</li> <li>Significant updates in the binary format, with more offsets being relative and lengths in place of a second offset.</li> <li>Fixed signatures for <code>from_binary</code> removing string_views in place of <code>std::span&lt;const uint8_t&gt;</code>, and fixed some return types which were not set to <code>const</code>.</li> <li>Other minor differences might be present due to the changes discussed prior, it is too hard to spot and report all of them, check the commit diffs to see the all.</li> </ul>"},{"location":"specs/formats/","title":"Formats","text":""},{"location":"specs/formats/#memory-layout","title":"Memory Layout","text":""},{"location":"specs/formats/#layout-encoding","title":"Layout encoding","text":""},{"location":"specs/formats/#binary-serialization","title":"Binary serialization","text":"<p>Except for a small header, the binary serialization of a tree is identical to its representation in memory.</p>"},{"location":"specs/formats/#header-format","title":"Header format","text":"<p>TBW.</p>"},{"location":"specs/formats/#multi-doc-archives","title":"Multi-doc archives","text":"<p>TBW.</p>"},{"location":"specs/formats/#indices","title":"Indices","text":"<p>TBW.</p>"},{"location":"specs/queries/","title":"Queries","text":""},{"location":"specs/queries/#what-are-queries","title":"What are queries?","text":"<p>Queries are the main mechanism to perform search operations on the binary XML files. There are three main clause types:</p> <ul> <li><code>is</code> iterates over all nodes form a container (like a prior query) as long as all criteria are met.</li> <li><code>has</code> iterates over all nodes from a container (like a prior query), for which the <code>is</code> clause is tested against the query criterion. Those for which at least one solution is defined are picked.</li> <li><code>maps</code> (not implemented yet) iterates over all nodes from a container (like a prior query), and matches results for node in the query tree onto a map-like structure. </li> </ul>"},{"location":"specs/queries/#structure-of-queries","title":"Structure of queries","text":"<p>A query is a linear sequence of query tokens. Most are meant to match specific features of the XML nodes, while some are used to control the \u201cmachine\u201d running the query validation process. Every complete query should end with an <code>accept()</code> token.</p>"},{"location":"specs/queries/#basic-commands","title":"Basic commands","text":"<ul> <li><code>fork()</code> to force splitting matching by continuing here and expanding down.</li> <li><code>accept()</code> to accept the current node and let the iterator go deeper.</li> <li><code>type({...})</code> to match a subset of node type.</li> <li><code>match_ns({exp})</code> to match the namespace, with exp being either a string or a boolean lambda.</li> <li><code>match_name({exp})</code> to match the name, with exp being either a string or a boolean lambda.</li> <li><code>match_value({exp})</code> to match the value, with exp being either a string or a boolean lambda.</li> <li><code>match_all_text({exp})</code> to match the text, with exp being either a string or a boolean lambda.</li> <li><code>attr({name, fn, ns})</code> if a given attribute (with namespace) satisfies the expressions (as string or boolean lambdas). </li> </ul>"},{"location":"specs/queries/#about-attributes","title":"About attributes","text":"<p>Attributes are handled differently compared to the rest of the XML nodes, because they are not. <code>attr</code> will exclusively test the attribute and not bind or capture it. This is true even when running <code>is</code> clauses. If you must capture attributes, you will have to do that by manually iterating or filtering them, like <code>item.attrs() | std::views::filter(...)</code>.</p>"},{"location":"specs/queries/#string-shorthands","title":"String shorthands","text":"<p>Several of the basic commands introduce earlier are also available in a simplified form, represented by string views:</p> <ul> <li><code>\"{ns}:{name}\"</code> matching namespace and name. Special values <code>?</code> for each to determine anything matches that slot. Empty string is considered empty string, and not a generic \u201cmatch all\u201d.</li> <li><code>*</code> to accept any node and move forward.</li> <li><code>**</code> to recursively fork.</li> </ul>"},{"location":"specs/queries/#composition","title":"Composition","text":"<p>Tokens of a query can be composed by any of the following operators:</p> <ul> <li><code>operator*</code> to append right to the current (left) list</li> <li><code>operator/</code> to append a <code>next()</code> AND right to left.</li> </ul>"},{"location":"specs/queries/#applying-queries","title":"Applying queries","text":"<p>Queries are applied either by:</p> <ul> <li>Using the <code>is</code>, <code>has</code> or <code>capture</code> functions.</li> <li>The operators <code>&amp;</code> and <code>|</code> which are alias for <code>is</code> and <code>has</code> respectively.</li> </ul> <p>Applied queries return asynchronous generators, so they can be further piped by <code>std::views::filter</code>.</p>"},{"location":"specs/query-builder/","title":"Query builder","text":"<p>Not implemented yet, just basic specs to sketch a new feature built on top of queries (and to build queries).</p> <p>Queries as they are right now are flexible, but not optimal for all applications:</p> <ul> <li>They cannot be easily serialized and de-serialized as they involve <code>std::function</code> in the variadic.</li> <li>They cannot be easily hashed for the reason above, and because they are made of many split memory segments.</li> <li>The lack of a quick way to hash makes the process of caching queries impractical.</li> </ul> <p>This proposal introduces a flat-tree representation for queries, which are going to perform better in those specific instances. They will be unable to store lambdas, but it is always possible to add some kind of scripting capability I guess (downstream, I don\u2019t think it is good to have that in here).</p> <p>Unlike the tree navigation of XML, where being able to go back to parent with no further contextual information is important, queries are always directed downwards. Also, aside for alignment purposes, there is no good reason to leave strings in a separate table, and they are much more less likely to be repeated. So having a split structural and symbol table might not be as beneficial.  </p> <p>Still, a layout of fully regular cells seems quite a good idea to me.</p> <p>Sketching layout or something.</p> <pre><code>BEGIN(3) OP OP OP \n    BEGIN(0)\n        BEGIN(1) OP\n        END\n        BEGIN(2) OP OP\n        END\n    END\n    BEGIN(0)\n        BEGIN(1) OP\n        END\n    END\nEND\nEOQ #end of query\n\n</code></pre> <p>Extra operation <code>END</code> used to mark end of branch and trace back.</p> <p>Operands are only string_views, details about their interpretation is left to the BEGIN block. END blocks only cover an offset to the parent, to ensure navigation back is possible.  Fully linear structures can avoid storing end tags, as they will never be used.</p> <pre><code>struct token_base{\n    operation_t op;     //5 bits\n    size_t operands;    //~~4~~ 3 bits\n\n    operands type = 8 * 2 bit = 16bit.\n\n    payload/alignment   //WORD-8bit\n};\n\nstruct operand_t{\n    data_kind_t kind;\n    std::string_view data;\n}\n\n</code></pre>"}]}