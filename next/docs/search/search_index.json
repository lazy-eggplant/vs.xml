{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Warning</p> <p>Ongoing project, not ready for release or usage yet. Many features are still missing.</p> <p>This library offers a mostly-compliant<sup>1</sup> XML parser, tree builder and several related utilities. It is not intended as a general purpose library, which means it might not be a good fit for your project. Please, read the rest of this readme to know more about its objectives and drawbacks.</p> <ol> <li> <p>XML 1.0 is covered as a best-effort, but there will be small things where either the official XML standard or this implementation is going to be incompatible or a superset.   For more information on compatibility, please check here.\u00a0\u21a9</p> </li> </ol>"},{"location":"faq/","title":"Faq","text":"<p>Why the binary serialization of the XML is bigger compared to the base file?</p> <p>That is to be expected. XML has little overhead with extra symbols and marker. By comparison, nodes as represented by this library are storing contextual information about their neighbours to speed up navigation. This additional pre-computed information is the reason for the extra space needed. Even when compressed via gzip, the source XML has a meaningful edge.  </p> <p>So why should I save the binary serialization?</p> <p>Because you don\u2019t need to parse the file any longer. You just need to memory-map it and use it as is. This lowers start-up time quite a bit.</p> <p>What is the point of a representation which is not mutable?</p> <p>It is not immutable, it is just that some mutations would be very expensive, almost like rebuilding the tree from scratch. However, there are some mutations which are still viable, like reordering attributes, changing value if the new literal is already in memory, or removing nodes/leaves. Some of them are implemented by the library, others could be.  </p> <p>As for why, there is plenty of applications where there is no need to mutate the tree structure after its build process has ended. This library tries to optimize for such cases as much as possible.</p> <p>Why pointers are relative?</p> <p>To allow them to be serialized and still provide random access on the tree regardless of the device or medium on which it is being stored. This allows to share annotations for a tree for cheap even in offloaded contexts.</p> <p>Why is XML serialization/de-serialization single threaded?</p> <p>Because they are mostly meant as one-shot operations, while the bulk of the operations is going to be on the binary representation. There is no trivial way to make XML parsing or serialization \u201cparallel\u201d without making the code involved much more complex, and it is better to have different thread serialize different files if possible.</p>"},{"location":"features/","title":"Features","text":""},{"location":"features/#standard-compatibility","title":"Standard compatibility","text":""},{"location":"features/#features","title":"Features","text":""},{"location":"features/#xml-parsing","title":"XML parsing","text":"<ul> <li> namespaces <sup>1</sup></li> <li> cdata<ul> <li> optional reduction to <code>text</code></li> </ul> </li> <li> text<ul> <li> optional merging of close text blocks</li> </ul> </li> <li> comments <ul> <li> optional stripping</li> </ul> </li> <li> basic entities</li> <li> complex entities</li> </ul>"},{"location":"features/#tree-builder","title":"Tree builder","text":"<ul> <li> namespaces</li> <li> processing</li> <li> cdata</li> <li> text</li> <li> comments</li> </ul>"},{"location":"features/#algorithms","title":"Algorithms","text":"<ul> <li> iterators for nodes</li> <li> iterators for attributes</li> <li> tree/sub-tree cloning<ul> <li> Basic copy</li> <li> String compression</li> </ul> </li> <li> attributes reordering</li> <li> node injection</li> <li> simplified tree wrapper to avoid xml::sv-&gt;string_view conversions.</li> </ul>"},{"location":"features/#xml-serialization","title":"XML serialization","text":"<ul> <li> namespaces</li> <li> processing</li> <li> cdata</li> <li> text</li> <li> comments</li> <li> output configurability<ul> <li> indentation</li> <li> newline style</li> <li> other linting</li> </ul> </li> </ul> <ol> <li> <p>Partially, no validation for them\u00a0\u21a9</p> </li> </ol>"},{"location":"layout/","title":"Layout","text":""},{"location":"layout/#memory-layout","title":"Memory Layout","text":"<p>The memory layout for the tree structure used by this library has the following properties: - It is based on a contiguous memory slice. - It is built in-place, as such children are placed directly after their parent. - Attributes are immediately stored after a node. - Pointers between nodes in the tree are not defined as absolute, but relative to the address of the current one. - All strings are represented as string views over a common base offset which is valid for the whole tree.</p> <p>The structure of the various nodes is based on the size of three data types:</p> <ul> <li><code>delta_ptr_t</code> is the type of relative pointers. Realistically, 16bits is plenty enough for most realistic scenarios with XML files humans can handle.</li> <li><code>xml_size_t</code> is the type used to represent the size of nodes in bytes. It should be as high as the max size in byte a tree can have. 16bits is also often sufficient.</li> <li><code>xml_count_t</code> is the type used to represent the count of things. Like the number of attributes, or number of bytes in a string. Its size is mostly determined by the maximum length of strings_views. Depending on the application as low as 8bit could be enough, 16bit a more reasonable default.</li> <li><code>xml_enum_size_t</code> is the size of enums when stored. 8bit is plenty enough.</li> </ul> <p>Note</p> <p>If you have very specific needs for a compact memory layout, probably more suitable for embedded applications, you will have to manually override parts of this code and possibly work with bit-fields.  This goes beyond the configurability granted via macros, and forking this library is likely the best solution.</p>"},{"location":"layout/#binary-serialization","title":"Binary serialization","text":"<p>Except for a small header, the binary serialization of a tree is identical to its representation in memory.</p>"},{"location":"layout/#header-format","title":"Header format","text":"<p>TBW.</p>"},{"location":"modes/","title":"Modes","text":"<p>The <code>TreeBuilder</code> is parametrized by a configuration structure and initialized in ways which defines its behaviour and ownership of data.</p>"},{"location":"modes/#configuration-fields","title":"Configuration fields","text":"<ul> <li><code>allow_comments</code> if true allows comments to be appended in the tree, else they are silently skipped (but can still throw exceptions for validation)</li> <li><code>allow_procs</code> if true allows processing directives to be appended in the tree, else they are silently skipped (but can still throw exceptions for validation)</li> <li><code>symbols</code>:<ul> <li><code>EXTERN_ABS</code> using full memory in absolute position; the generated tree cannot be saved as binary.</li> <li><code>EXTERN_REL</code> can be saved as binary, but it requires the tree to bind a symbol table later when constructed.</li> <li><code>OWNED</code> no compression of symbols, but they are owned.</li> <li><code>COMPRESS_LABELS</code> only compressing symbols which are used for tag and prop labels (and namespaces).</li> <li><code>COMPRESS_ALL</code> all symbols are compressed.</li> </ul> </li> <li><code>raw_strings</code> if true, strings are assumed to be kept as is when serialized or deserialized from XML. Make sure you manually escape those used in comparisons or to append further data.</li> </ul>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#installing","title":"Installing","text":"<p>Use it as a meson dependency, be it a subproject of after installing it on your system.  </p> <p>The process is basically as usual:</p> <pre><code>meson setup build           #Add more flags to setup release, lto optimizations etc based on your needs\nmeson install -C build      #You might have to define DESTDIR to perform a dry run or if you have a strange location\n</code></pre> <p>A simplified makefile is made available, which has some reasonable defaults.  </p> <p>Tarballs are also offered for some distributions in releases.  </p>"},{"location":"usage/#usage","title":"Usage","text":"<p>TBW</p>"}]}